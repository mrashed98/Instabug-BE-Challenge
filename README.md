# Instabug Backend Challenge

This repository contains the backend implementation for the **Instabug BE Challenge**, built with Ruby on Rails and Docker to handle chat-related functionality efficiently.

## Table of Contents
- [Project Overview](#project-overview)
- [Tech Stack](#tech-stack)
- [Database Design](#database-design)
- [System Design](#system-design)
- [Setup Instructions](#setup-instructions)
- [API Endpoints](#api-endpoints)
- [Testing](#testing)


## Project Overview

This project is a challenge that implements a simple backend for managing chat functionalities, including creating and managing chats, using Rails, Sidekiq for background processing, and MySQL as the database. The project is containerized with Docker for easy deployment and development.

## Tech Stack
- **Ruby on Rails** - Backend framework
- **MySQL** - Database
- **Sidekiq** - Background job processing
- **Redis** - Queueing system for Sidekiq
- **Docker** - Containerization for the project
- **Elasticsearch** - Search engine integration (for scalable search functionality)


## Database design

<img width="712" alt="image" src="https://github.com/user-attachments/assets/a24016b8-a524-4eb9-87d3-9522cf28effa">


## System design

### Application Layer:

- **Ruby on Rails**: Handles most of the core application logic and routing.
- **Go Service**: Include chat and messages features (chat creation, message storage, etc.). REST API endpoints for chat and message management.
- **Elastic Search**: Search engine for messages
- **Sidekiq**: Queuing system for updating chat counts and messages count
- **Redis**: Queuing chats and messages creation

  
### Database Layer:

- **MySQL**: For storing app, chat and message data (apps, chats, messages).
- Use of ActiveRecord in Rails for database interactions.
- Use mysql driver in Go for database interactions.

### Indexes
* Created in chats table index on ```appToken``` and ```number``` in the same order. to be able to get chats by ```appToken``` and ```number``` faster or to get chats by ```appToken``` only. this index works for both.
* created in messages table index on ```chat_id``` and ```number``` in the same order. to be able to get messages by ```chat_id``` and ```number``` faster or to get messages by ```chat_id``` only. this index works for both

  
### Message Queue:

- Redis (used with Sidekiq) in Rails: To handle background jobs (e.g., updating chats_count and messages_count every 50m).
- Redis (used only) in Go: To handle background jobs (e.g creating chats, creating messages).

### Racing Condition
In this challenge there are multiple race conditions. one of them is the race condition that can occur while inserting new message or chat. since the chat number or message number are generated by the system, not the database. So we want to handle this condition if two requests want to add new messages or chats at the same time.

In this case, I used [Redis atomic Increment](https://redis.io/commands/incr/) function. this function provides me exactly what i want, Increment atomic function means that only one instance can access it at a time. 
### Elasticsearch
Elasticsearch is used to search over the messages partially. Elasticsearch Indexed on ```Chat_id``` not analyzed and ```content``` with English analyzer. 
```
query: { 
      bool: { 
        must: {
          match_phrase: {
            body: query,
          }
        },
        filter: {
          term: {
            "chat_id" => chat_id
          }
        }
      }
```
This query is used to filter all the documents by ```chat_id``` and match the result with search term (query) provided by the user.
### Job Queuing
Here i used ```Sidekiq``` for two main purposes.
   1. To provide asynchronous queue for inserting the messages and chats requests into the database.
   2.  Using ```Sidekiq Scheduler``` to schedule a two jobs. The first Job ```App Chat Counter``` to calculate the number of chats connected to each application. The second Job ```Chat Message Counter``` to calculate the number of messages connected to each chat. Both Jobs run every ```50 minutes```.

### Containerization & Deployment:

- **Docker:** Both Ruby on Rails and Go services are containerized for consistent deployment.
- **Docker Compose:** To orchestrate multiple containers (Rails app, Go service, Redis, MySQL, elasticsearch).

## Setup Instructions

### Prerequisites
- Docker and Docker Compose installed
- Make sure that these ports are available. Port:9200 (Elasticsearch) Port:6379 (Redis) Port:3307 (mysql) Port:3000 (API)
  
### Steps
1. **Clone the repository:**
   ```bash
   git clone https://github.com/mrashed98/Instabug-BE-Challenge.git
   cd Instabug-BE-Challenge
   ```

   - ***For ruby only version please checkout to `ruby-only` branch***
   
   - ***Rspec available in the `ruby-only` branch***
   
3. Set up environment variables: Copy the .env.example to .env and configure the variables (e.g., MySQL password, Redis URL).

4. Build and run the Docker containers:
   ```bash
   docker-compose up --build
   ```

### API Endpoints

#### Applications

 - Get all applications
   - Method `GET`
   - Endpoint `/applications`
   - Description -> `It gets all the applications on the system`
   - Expected Returned object `List of Application Object`
     
   ```json
   [
    {
        "token": "fpiQbRiR3MsUB5p52zsfn7JX",
        "name": "Re-engineered non-volatile moratorium",
        "chats_count": 2,
        "created_at": "2024-09-22T19:02:33.827Z",
        "updated_at": "2024-09-22T21:12:08.844Z"
    },
    {
        "token": "wNrw5Q17Ae6R9Pxfh4rV1kFF",
        "name": "Object-based",
        "chats_count": 0,
        "created_at": "2024-09-22T23:14:19.246Z",
        "updated_at": "2024-09-22T23:14:19.246Z"
    },
    {
        "token": "qCLJ3f4V9yx3NFZoBBiihHY8",
        "name": "Triple-buffered",
        "chats_count": 0,
        "created_at": "2024-09-22T23:14:19.880Z",
        "updated_at": "2024-09-22T23:14:19.880Z"
    }
   ]
   ```

- Get Specific application
  - Method `GET`
  - Endpoint `/applications/:application_token/`
  - Description -> `It Gets the data for specific application`
  - Expected Returned object `Application object`
 
    ```json
    {
    "token": "fpiQbRiR3MsUB5p52zsfn7JX",
    "name": "Re-engineered non-volatile moratorium",
    "chats_count": 2,
    "created_at": "2024-09-22T19:02:33.827Z",
    "updated_at": "2024-09-22T21:12:08.844Z"
    }
    ```
- Create new application
  - Method `POST`
  - Endpoint `/applications/new`
  - Description -> `It create new application`
  - Params `name` -> type `string`
  - Expected Returned object `The created application token`
 
    ```json
    {
    "token": "xu5TZL5Gwahy311izQc8WMqg"
    }
    ```
- Update application name
  - Method `PUT`
  - Endpoint `/applications/:application_token/update`
  - Description -> `Update the application name
  - Params `name` -> type `string`
  - Expcted returned output `Update successfull msg`

#### Chats

   - Get all Chats
      - Method `GET`
      - Endpoint `/applications/:application_token/chats/`
      - Description -> `Get all Chats for specific application`
      - Expected Returned object `List of Chats`
    
        ```json
        [
             {
                 "number": 1,
                 "messages_count": 1,
                 "created_at": "2024-09-24T11:07:55.287793Z",
                 "updated_at": "2024-09-24T11:56:30.406825Z"
             },
             {
                 "number": 2,
                 "messages_count": 0,
                 "created_at": "2024-09-24T14:46:55.173997Z",
                 "updated_at": "2024-09-24T14:46:55.173997Z"
             }
         ]
        ```
     - Get specific Chat
        - Method `GET`
        - Endpoint `/applications/:application_token/chats/:chat_number`
        - Description `Get specific chat data for specific app`
        - Expected returned output `Get Chat object`
      
          ```json
          
             {
                 "number": 1,
                 "messages_count": 1,
                 "created_at": "2024-09-24T11:07:55.287793Z",
                 "updated_at": "2024-09-24T11:56:30.406825Z"
             },
          ```

     - Create new chat
        - Method `POST`
        - Endpoint `/applications/:application_token/chats/new`
        - Description `Create new chat for specific application`
        - Expected returned output `chat number created`
      
          ```json
          {
             "chat_number": 3
          }
          ```

### Messages 
   - Get all messages
      - Method `GET`
      - Endpoint `/applications/:application_token/chats/1/messages`
      - Description `Get all messages for specific app and specific chat`
      - Expected returned output `List of messages object`
    
        ```json
           [
             {
                 "number": 1,
                 "body": "Function-based real-time standardization",
                 "created_at": "2024-09-24T11:08:32.180398Z",
                 "updated_at": "2024-09-24T11:08:32.180398Z"
             },
             {
                 "number": 2,
                 "body": "Upgradable solution-oriented interface",
                 "created_at": "2024-09-24T14:55:20.539287Z",
                 "updated_at": "2024-09-24T14:55:20.539287Z"
             },
             {
                 "number": 3,
                 "body": "Reduced asynchronous collaboration",
                 "created_at": "2024-09-24T14:55:21.506979Z",
                 "updated_at": "2024-09-24T14:55:21.506979Z"
             },
             {
                 "number": 4,
                 "body": "Object-based executive paradigm",
                 "created_at": "2024-09-24T14:55:22.185313Z",
                 "updated_at": "2024-09-24T14:55:22.185313Z"
             }
         ]
        ```

     - Get specific message
       - Method `GET`
       - Endpoint `/applications/:application_token/chats/1/messages/:message_number`
       - Description `Get specific message for specific application and specific chat`
       - Expected returned output `Message object`

          ```json
          {
             "number": 1,
             "body": "Function-based real-time standardization",
             "created_at": "2024-09-24T11:08:32.180398Z",
             "updated_at": "2024-09-24T11:08:32.180398Z"
         }
          ```

      - Create new message
         - Method `POST`
         - Endpoint `/applications/:application_token/chats/1/messages/new`
         - Description `Create new message for specific app and specific chat`
         - Parameters `body: string`
         - Expected returned output `Created message number`
       
           ```json
              {
                   "message_number": 5
               }
           ```

      - Update message
         - Method `PUT`
         - Endpoint `/applications/:application_token/chats/1/messages/:message_number`
         - Description `Update Already Created message`
         - Parameters `body: string`
         - Expected returned output `Update successfull msg`
    
      - Search message
         - Method `POST`
         - Endpoint `/applications/:application_token/chats/1/messages/search`
         - Description `Search of message in specific chat for specific app`
         - Parameters `query:string`
         - Expected returned output `List of partial matched messages`

           ```json
             {
                "number": 1,
                "body": "Function-based real-time standardization",
                "created_at": "2024-09-24T11:08:32.180398Z",
                "updated_at": "2024-09-24T11:08:32.180398Z"
            }
           ```
## Testing
Created Unit Tests for Application and Chats Controllers/Models Using RSpec.
**Caution:** test enviroment uses the same database the development enviroment uses. So be careful, becasue I added database cleaner before performing the test cases, and tests that would delete all the records in the database before performing the test cases.

You can run the test case by the following command:

```sudo docker-compose exec app bundle exec rspec```

You have to make sure that the docker images are running first before executing the test cases.
